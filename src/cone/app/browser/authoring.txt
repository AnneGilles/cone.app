Authoring
=========

There are two pyramid views registered, ``add`` and ``edit``. These views render
the main template with the ``add`` respective ``edit`` tile as content tiles 
which render the ``addform`` or ``editform`` tiles.


Adding
------

Using the built-in adding mechanism.

Create dummy node::

    >>> from cone.app.model import BaseNode
    >>> from cone.app.model import getNodeInfo
    >>> class MyNode(BaseNode):
    ...     node_info_name = 'mynode'

Now, if we want to use the build-in adding mechanism, we need to
provide NodeInfo for our application nodes::

    >>> from cone.app.model import BaseNodeInfo, registerNodeInfo
    >>> mynodeinfo = BaseNodeInfo()
    >>> mynodeinfo.title = 'My Node'
    >>> mynodeinfo.description = 'This is My node.'
    >>> mynodeinfo.node = MyNode
    >>> mynodeinfo.addables = ['mynode']
    >>> registerNodeInfo('mynode', mynodeinfo)

Create and register an addform tile for MyNode::

    >>> from plumber import plumber
    >>> from yafowil import loader
    >>> from yafowil.base import factory
    >>> from cone.tile import tile
    >>> from cone.app.browser.utils import make_url
    >>> from cone.app.browser.form import Form
    >>> from cone.app.browser.authoring import AddPart
    
    >>> @tile('addform', interface=MyNode)
    ... class MyAddForm(Form):
    ...     __metaclass__ = plumber
    ...     __plumbing__ = AddPart
    ...     
    ...     def prepare(self):
    ...         form = factory(u'form',
    ...                        name='addform',
    ...                        props={'action': self.nodeurl})
    ...         form['id'] = factory(
    ...             'field:label:text',
    ...             props = {
    ...                 'label': 'Id',
    ...             })
    ...         form['title'] = factory(
    ...             'field:label:text',
    ...             props = {
    ...                 'label': 'Title',
    ...             })
    ...         form['add'] = factory(
    ...             'submit',
    ...             props = {
    ...                 'action': 'add',
    ...                 'expression': True,
    ...                 'handler': self.add,
    ...                 'next': self.next,
    ...                 'label': 'Add',
    ...             })
    ...         self.form = form
    ...     
    ...     def add(self, widget, data):
    ...         fetch = self.request.params.get
    ...         child = MyNode()
    ...         child.attrs.title = fetch('addform.title')
    ...         self.model.__parent__[fetch('addform.id')] = child
    ...         
    ...     def next(self, request):
    ...         return '<div>Added</div>'

A small patch to make tests work with test request::

    >>> def authenticated(request):
    ...     return True
    >>> import cone.app.browser.layout
    >>> cone.app.browser.layout.authenticated = authenticated

Now create dummy root and render ``add`` tile::

    >>> import cone.app.browser.authoring
    >>> from pyramid.testing import DummyRequest
    >>> from cone.tile import render_tile
    >>> request = DummyRequest()
    >>> root = MyNode()
    >>> layer.authenticate('editor')

Render without factory::

    >>> render_tile(root, request, 'add')
    u'Unknown factory'

Render with valid factory::

    >>> request.params['factory'] = 'mynode'

    >>> render_tile(root, request, 'add')
    u'<form action="http://example.com" ...'

Render with submitted data::
    
    >>> request.params['action.addform.add'] = '1'
    >>> request.params['addform.id'] = 'somechild'
    >>> request.params['addform.title'] = 'Some Child'

    >>> render_tile(root, request, 'add').find('Added') != -1
    True

Check the modified model::

    >>> root.keys()
    ['somechild']
    
    >>> root['somechild'].attrs.title
    'Some Child'


Editing
-------

Providing edit forms is easy, just bind a form tile named 'editform' for your
application node::

    >>> from cone.app.browser.authoring import EditPart

    >>> @tile('editform', interface=MyNode)
    ... class MyEditForm(Form):
    ...     __metaclass__ = plumber
    ...     __plumbing__ = EditPart
    ...     
    ...     def prepare(self):
    ...         form = factory(u'form',
    ...                        name='editform',
    ...                        props={'action': self.nodeurl})
    ...         form['title'] = factory(
    ...             'field:label:text',
    ...             value = self.model.attrs.title,
    ...             props = {
    ...                 'label': 'Title',
    ...             })
    ...         form['update'] = factory(
    ...             'submit',
    ...             props = {
    ...                 'action': 'update',
    ...                 'expression': True,
    ...                 'handler': self.update,
    ...                 'next': self.next,
    ...                 'label': 'Update',
    ...             })
    ...         self.form = form
    ...     
    ...     def update(self, widget, data):
    ...         fetch = self.request.params.get
    ...         self.model.attrs.title = fetch('addform.title')
    ...         
    ...     def next(self, request):
    ...         return '<div>Updated</div>'

Render form with values from model::

    >>> request = DummyRequest()
    >>> render_tile(root['somechild'], request, 'edit')
    u'<form action="http://example.com/somechild" ...'

Trigger update action and provide new title::

    >>> request.params['action.editform.update'] = '1'
    >>> request.params['addform.title'] = 'Changed title'

Check the results::

    >>> render_tile(root['somechild'], request, 'edit').find('Updated') != -1
    True
    
    >>> root['somechild'].attrs.title
    'Changed title'


Add Items Dropdown Widget
-------------------------

You can render an item dropdown in your application which renders a dropdown
menu containing links to the addforms of allowed child nodes::

    >>> request = DummyRequest()
    >>> rendered = render_tile(root['somechild'], request, 'add_dropdown')

Non JS Fallback link to add item view (view itself not implemented yet)::
    
    >>> rendered.find('href="http://example.com/somechild/adding"') != -1
    True

Non JS link to add form::

    >>> expected = 'href="http://example.com/somechild/add?factory=mynode"'
    >>> rendered.find(expected) != -1
    True

Ajax target for add form::

    >>> expected = 'ajax:target="http://example.com/somechild?factory=mynode"'
    >>> rendered.find(expected) != -1
    True

Ajax action rule for add form::

    >>> expected = 'ajax:action="add:#content:inner"'
    >>> rendered.find(expected) != -1
    True


Allow another node type as child::

    >>> nodeinfo = BaseNodeInfo()
    >>> nodeinfo.title = 'Another Node'
    >>> nodeinfo.description = 'This is another node.'
    >>> nodeinfo.node = BaseNode
    >>> nodeinfo.addables = []
    >>> registerNodeInfo('anothernode', nodeinfo)
    >>> getNodeInfo('mynode').addables = ['mynode', 'anothernode']
    
    >>> rendered = render_tile(root['somechild'], request, 'add_dropdown')
    
Non JS links to add form::

    >>> expected = 'href="http://example.com/somechild/add?factory=mynode"'
    >>> rendered.find(expected) != -1
    True
    
    >>> expected = 'href="http://example.com/somechild/add?factory=anothernode"'
    >>> rendered.find(expected) != -1
    True

Ajax targets for add form::

    >>> expected = 'ajax:target="http://example.com/somechild?factory=mynode"'
    >>> rendered.find(expected) != -1
    True
    
    >>> expected = 'ajax:target="http://example.com/somechild?factory=anothernode"'
    >>> rendered.find(expected) != -1
    True
    
    >>> layer.logout()
